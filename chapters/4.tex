% Chapter 4

\chapter{Architecture}

\label{ch:architecture}

%----------------------------------------------------------------------------------------

\section{Overview}\label{sec:overview}

\tangible{} is implemented as a single Python package, without any external
dependencies.

The architecture of \tangible{} can be categorized into four different parts: The
\hyperref[sec:ast]{abstract syntax tree (AST)}, \hyperref[sec:backends]{code
generation backends}, \hyperref[sec:shapes]{shapes} and
\hyperref[sec:utils]{utils}.

\vspace{7mm}

\begin{figure}[H]
	\centering
	\input{tikz/architecture}
	\caption{Architecture Diagram}
	\label{img:architecture}
\end{figure}

%----------------------------------------------------------------------------------------

\section{AST}\label{sec:ast}

The \texttt{ast.py} module provides the objects for the abstract syntax tree
(AST) for \tangible{}. All AST objects extend a single base class called
\texttt{AST}. This base class is responsible for three things:

\begin{itemize}
	\item It provides a single base type to use for type checking, e.g.
		\texttt{isinstance(mysubclass, ast.AST)}.
	\item It overrides the \texttt{\_\_eq\_\_} and \texttt{\_\_ne\_\_} methods in
		a way that all subclasses are compared by value (using
		\texttt{self.\_\_dict\_\_}), and not by identity.
	\item It provides a \texttt{\_\_repr\_\_} implementation that displays both
		the class name as well as the object memory address, which simplifies
		debugging.
\end{itemize}

\noindent The module contains the following classes:

\subsection{Base Class}

\begin{itemize}
	\item \texttt{AST}: The base shape for all AST elements, as described above.
\end{itemize}

\subsection{2D Shapes}

\begin{itemize}
	\item \texttt{Circle}: A circle shape with a specified radius.
	\item \texttt{CircleSector}: A circle sector shape (pizza slice) with a
		specified radius and angle.
	\item \texttt{Rectangle}: A rectangular shape with a specified width and
		height.
	\item \texttt{Polygon}: A polygon shape made from a list of 2D coordinates.
\end{itemize}

\subsection{3D Shapes}

\begin{itemize}
	\item \texttt{Cube}: A cube with a specified width, height and depth.
	\item \texttt{Sphere}: A sphere with a specified radius.
	\item \texttt{Cylinder}: A cylinder with a height and top/bottom radii.
	\item \texttt{Polyhedron}: An arbitrary 3D shape made from connected triangles
		or quads.
\end{itemize}

\subsection{Transformations}

\begin{itemize}
	\item \texttt{Translate}: Used to translate an object.
	\item \texttt{Rotate}: Used to rotate an object.
	\item \texttt{Scale}: Used to scale an object.
	\item \texttt{Mirror}: Used to mirror an object.
\end{itemize}

\subsection{Boolean Operations}

\begin{itemize}
	\item \texttt{Union}: Combine multiple shapes into a single shape.
	\item \texttt{Difference}: A boolean difference of two or more shapes.
	\item \texttt{Intersection}: A boolean intersection of two or more shapes.
\end{itemize}

\subsection{Extrusions}

\begin{itemize}
	\item \texttt{LinearExtrusion}: Extrude a 2D object linearly along the z axis.
	\item \texttt{RotateExtrusion}: Extrude a 2D object around the z axis. 
\end{itemize}

%----------------------------------------------------------------------------------------

\section{Backends}\label{sec:backends}

The backends are responsible for code generation. They receive an
\hyperref[sec:ast]{AST} instance, traverse it and emit backend specific code.

At the time of this writing, only one backend has been implemented: The OpenSCAD
backend. But it's be very easy to add additional backends in the future.

\subsection{Creating Custom Backends}

To be valid, a custom backend simply needs to implement the following interface:

\vspace{.5\baselineskip}
\begin{pythoncode}
class CustomBackend(object):
    def __init__(self, ast):
        """Initialize backend using the provided AST."""
    def generate(self):
        """Generate code from AST and return it
        as a unicode string."""
\end{pythoncode}

\noindent The code generated by a backend is returned as a unicode string. It
can then be printed to the terminal or used for further processing.


TODO: cross-reference to implementation details

%----------------------------------------------------------------------------------------

\section{Shapes}\label{sec:shapes}

The \texttt{shapes} package is a key component of \tangible{}. It provides a
hierarchical collection of pre-defined shapes that can be used directly to
generate three dimensional data visualizations.

The package is organized into different files:

\begin{itemize}
	\item \texttt{base.py}: Base class for all shape objects.
	\item \texttt{mixins.py}: Mixins used in the shape classes, mostly used for
		data validation.
	\item \texttt{bars.py}: Bar like shapes.
	\item \texttt{vertical.py}: Vertical shapes, e.g. towers.
	\item \texttt{pie.py}: Circular "pie" shapes.
\end{itemize}

\begin{figure}[H]
	\centering
	\input{tikz/shapes}
	\caption{Shapes Architecture}
	\label{img:shapes}
\end{figure}

\subsection{Base Class}

The class \texttt{Shape} in \texttt{shapes/base.py} is the base class for all
predefined shapes in \tangible{}:

\vspace{.5\baselineskip}

\begin{pythoncode}
class BaseShape(object):
    def _build_ast(self):
        raise NotImplementedError("_build_ast method not implemented.")

    def render(self, backend):
        self.ast = self._build_ast()
        return backend(self.ast).generate()
    
class Shape(BaseShape):
    def __init__(self, data):
        self.data = utils.ensure_list_of_lists(data)
        if len(self.data[0]) == 0:
            raise ValueError("Data may not be empty.")
\end{pythoncode}

Each shape is initialized with the data as the first positional argument. Using
a helper function, single lists with one dimensional data are converted to
nested lists, to simplify the rendering code. Empty data is not allowed.

The \texttt{\_build\_ast()} method is not implemented in the base class. An
inheriting class needs to override the method and return an AST.

Finally, the \texttt{render(backend)} method renders the AST using the specified
backend class and returns the resulting source code as a unicode string.

\subsection{Mixins}

The mixin classes are used in combination with Python's multiple inheritance
system to provide "pluggable" generic data validation. At the time of this
writing, the following mixins are available:

\begin{itemize}
	\item \texttt{Data1DMixin}: Ensures that data contains exactly 1 dataset.
	\item \texttt{Data2DMixin}: Ensures that data contains exactly 2 datasets.
	\item \texttt{Data4DMixin}: Ensures that data contains exactly 4 datasets.
	\item \texttt{DataNDMixin}: Used for shapes where the number of data
		dimensions is not relevant. But it asserts that the data is not empty and
		that all data items are of a sequence type.
	\item \texttt{SameLengthDatasetMixin}: Ensures that all datasets have the same
		length.
\end{itemize}

The mixins are properly implemented using Python's argument list unpacking
(\texttt{\textsuperscript{*}args, \textsuperscript{**}kwargs}) and
\texttt{super()} calls, so that a class can use multiple mixins without breaking
.the inheritance chain. A good example where this is used is the
\texttt{RectangleTower2D} shape:

\vspace{.5\baselineskip}

\begin{pythoncode}
class RectangleTower2D(Data2DMixin,
    SameLengthDatasetMixin, VerticalShape):
    # ...
\end{pythoncode}

\subsection{Shape Classes}

\tangible{} provides different shapes ready to use. They are grouped into three
categories: Bar shapes, vertical shapes and  pie shapes.

\begin{itemize}
	\item Bar shapes consist of several bars that start on \texttt{z=0} and have a
		height depending on the corresponding datapoint. They can be aligned in
		rows, and rows can be combined to create 3D bar graphs.
	\item A vertical shape is a shape with layers stacked on top of each other,
		with a fixed layer height, for example a round tower where the radius
		corresponds to the datapoint.
	\item A pie shape can represent data as angle, height or radius of the
		corresponding slice. It is possible to define an inner radius ($\rightarrow$donut) and
		to explode the slices.
\end{itemize}

\noindent The naming of the shape classes follows a consistent pattern: First a
descriptive name of the shape (e.g. \texttt{RhombusTower} or
\texttt{RadiusHeightPie}), then the dimensionality of the data (e.g.
\texttt{1D}, \texttt{4D} or \texttt{ND}). A way to describe the data
dimensionality in Python terms would be \emph{\texttt{n}-dimensional data is a
list containing \texttt{n} lists}.

TODO a separate chapter or section containing all shapes

%----------------------------------------------------------------------------------------

\section{Utils}\label{sec:utils}

\subsection{Scales}

The module \texttt{scales.py} contains functions for mapping an input domain to
an output range (the codomain). For example it could be used to normalize
temperatures between 0\si{\degree}C and 100\si{\degree}C to values between 1 and
10. The scales are inspired by the quantitative scales in
\texttt{d3.js}\footnote{\url{https://github.com/mbostock/d3/wiki/Quantitative-Scales}}.

At the time of this writing, only a linear scale has been implemented. It
accepts three parameters: The domain, the codomain (output range), and whether
to clamp the values to the output range or not.

\vspace{.5\baselineskip}
\begin{pythoncode}
>>> from tangible import scales
>>> temperatures = [32, 60, 100, 0, 120, -50]
>>> domain = [0, 100]  # Input range
>>> codomain = [1, 10]  # Output range
>>> scale = scales.linear(domain, codomain, clamp=False)
>>> scale_clamp = scales.linear(domain, codomain=, clamp=True)
\end{pythoncode}

\noindent The returned object is the actual scaling function:

\vspace{.5\baselineskip}
\begin{pythoncode}
>>> scale(0)
1.0
>>> scale(50)
5.5
>>> scale(100)
10.0
\end{pythoncode}

\noindent A very convenient way to use scales is by applying them using the
\texttt{map()} function:

\vspace{.5\baselineskip}
\begin{pythoncode}
>>> map(scale, temperatures)
[3.88, 6.3999999999999995, 10.0, 1.0, 11.799999999999999, -3.5]
>>> map(scale_clamp, temperatures)
[3.88, 6.3999999999999995, 10.0, 1.0, 10, 1]
\end{pythoncode}

\noindent Logarithmic and exponential scales as well as dynamic resizing of
domains / codomains are currently not implemented, but will follow in the
future.

\subsection{Helper Functions}

The module \texttt{utils.py} contains different helper functions to simplify
common tasks.


\subsubsection{\texttt{pairwise(iterable)}}

\noindent This function returns a generator acting as a sliding window over an iterable.
Each item returned by the generator is a 2-tuple containing two consecutive
items from the original iterable.

\vspace{.5\baselineskip}

\noindent Example:

\vspace{.5\baselineskip}
\begin{pythoncode}
>>> from tangible import utils
>>> pairs = utils.pairwise([1, 2, 3, 4, 'a'])
>>> pairs
<itertools.izip object at 0xeea098>
>>> list(pairs)
[(1, 2), (2, 3), (3, 4), (4, 'a')]
\end{pythoncode}


\subsubsection{\texttt{reduceby(iterable, keyfunc, reducefunc, init)}}

This function combines the functionality of \texttt{itertools.groupby()} and
\texttt{reduce()}. It iterates over the iterable and aggregates the values using
the specified reduce function and init value as long as \texttt{keyfunc(item)}
returns the same value. Each time the key changes, the aggregated value is
yielded.

A possible use case could be the aggregation of website visits, grouped by
month. The corresponding SQL statement would be:

\vspace{.5\baselineskip}
\begin{minted}[bgcolor=tango-bg,frame=lines,framesep=2mm,samepage=true,fontsize=\footnotesize]{sql}
SELECT SUM(visit_count) FROM visits GROUP BY MONTH(visit_date);
\end{minted}

\noindent Example:

\vspace{.5\baselineskip}
\begin{pythoncode}
>>> from datetime import date
>>> from tangible import utils
>>> visits = [(date(2013, 1, 24), 27),
...           (date(2013, 1, 26), 4),
...           (date(2013, 2, 17), 19),
...           (date(2013, 3, 11), 23),
...           (date(2013, 3, 14), 42)]
>>> keyfunc = lambda x: x[0].month
>>> reducefunc = lambda x, y: x + y[1]
>>> groups = utils.reduceby(visits, keyfunc, reducefunc, 0)
>>> groups
<generator object reduceby at 0xedc5a0>
>>> list(groups)
[31, 19, 65]
\end{pythoncode}


\subsubsection{\texttt{connect\_2d\_shapes(shapes,layer\_distance, orientation)}}

This is quite a complex function. It connects a list of 2D shapes into a 3D
shape using the desired layer distance. The \texttt{orientation} argument
specifies, whether the shapes should be joined horizontally or vertically.

The main part of the function has separate implementations depending on the 2D
object. Circles are connected by joining cylinders, while rectangles and
polygons are connected by joining polyhedra.

\vspace{.5\baselineskip}

\noindent Example:

\vspace{.5\baselineskip}
\begin{pythoncode}
>>> from tangible import utils, ast
>>> shapes = [ast.Circle(3), ast.Circle(8), ast.Circle(5)]
>>> utils.connect_2d_shapes(shapes, layer_distance=10,
...     orientation='vertical')
<AST/Union: 21376464>
\end{pythoncode}


\subsubsection{\texttt{\_quads\_to\_triangles(quads)}}

This function converts a list of quads (4-tuples) to a list of triangles
(3-tuples). This is mostly because many backends require surface meshes to
consist of triangles, without support for quads.

\vspace{.5\baselineskip}

\noindent Example:

\vspace{.5\baselineskip}
\begin{pythoncode}
>>> from tangible import utils
>>> quads = [(0, 1, 2, 3)]
>>> utils._quads_to_triangles(quads)
[(0, 1, 2), (0, 2, 3)]
\end{pythoncode}

\noindent The function is mostly used internally. A stable API is not guaranteed.


\subsubsection{\texttt{\_ensure\_list\_of\_lists(data)}}

This function ensures that the argument is a list of lists. If it doesn't
contain lists or tuples, it is wrapped in a list and returned.

\vspace{.5\baselineskip}

\noindent Example:

\vspace{.5\baselineskip}
\begin{pythoncode}
>>> utils._ensure_list_of_lists([1, 2, 3])
[[1, 2, 3]]
>>> utils._ensure_list_of_lists([[1, 2], [3]])
[[1, 2], [3]]
\end{pythoncode}

\noindent The function is mostly used internally. A stable API is not guaranteed.
